<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用 Linux 命令的基本使用]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ls 常用选项ls 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 ls 通配符的使用 * 代表任意个数个字符 ? 代表任意一个字符，至少 1 个 [] 表示可以匹配字符组中的任一一个 [abc] 匹配 a、b、c 中的任意一个 [a-f] 匹配从 a 到 f 范围内的的任意一个字符 cdcd 是英文单词 change directory 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一 注意：Linux 所有的 目录 和 文件名 都是大小写敏感的 cd ~ 切换到当前用户的主目录(/home/用户目录) cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 可以在最近两次工作目录之间来回切换 相对路径和绝对路径 相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对 当前目录 所在的目录位置 绝对路径 在输入路径时，最前面是 / 或者 ~，表示从 根目录/家目录 开始的具体目录位置 创建和删除操作touch创建文件或修改文件时间 如果文件 不存在，可以创建一个空白文件 如果文件 已经存在，可以修改文件的末次修改日期 mkdir 创建一个新的目录 选项 含义 -p 可以递归创建目录 新建目录的名称 不能与当前目录中 已有的目录或文件 同名 rm 删除文件或目录 使用 rm 命令要小心，因为文件删除后不能恢复 选项 含义 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹 时必须加此参数 拷贝和移动文件 序号 命令 对应英文 作用 01 tree [目录名] tree 以树状图列出文件目录结构 02 cp 源文件 目标文件 copy 复制文件或者目录 03 mv 源文件 目标文件 move 移动文件或者目录／文件或者目录重命名 tree tree 命令可以以树状图列出文件目录结构 选项 含义 -d 只显示目录 cp cp 命令的功能是将给出的 文件 或 目录 复制到另一个 文件 或 目录 中，相当于 DOS 下的 copy 命令 选项 含义 -i 覆盖文件前提示 -r 若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 mv mv 命令可以用来 移动 文件 或 目录，也可以给 文件或目录重命名 选项 含义 -i 覆盖文件前提示 查看文件内容 序号 命令 对应英文 作用 01 cat 文件名 concatenate 查看文件内容、创建文件、文件合并、追加文件内容等功能 02 more 文件名 more 分屏显示文件内容 03 grep 搜索文本 文件名 grep 搜索文本文件内容 cat cat 命令可以用来 查看文件内容、创建文件、文件合并、追加文件内容 等功能 cat 会一次显示所有的内容，适合 查看内容较少 的文本文件 选项 含义 -b 对非空输出行编号 -n 对输出的所有行编号 Linux 中还有一个 nl 的命令和 cat -b 的效果等价 more more 命令可以用于分屏显示文件内容，每次只显示一页内容 适合于 查看内容较多的文本文件 使用 more 的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串 grep Linux 系统中 grep 命令是一种强大的文本搜索工具 grep允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式，在就业班会详细讲解 选项 含义 -n 显示匹配行及行号 -v 显示不包含匹配文本的所有行（相当于求反） -i 忽略大小写 常用的两种模式查找 参数 含义 ^a 行首，搜寻以 a 开头的行 a$ 行尾，搜寻以 a 结束的行 echo echo 会在终端中显示参数指定的文字，通常会和 重定向 联合使用 重定向 &gt; 和 &gt;&gt; Linux 允许将命令执行结果 重定向到一个 文件 将本应显示在终端上的内容 输出／追加 到指定文件中 &gt; 表示输出，会覆盖文件原有的内容 &gt;&gt; 表示追加，会将内容追加到已有文件的末尾 管道 | Linux 允许将 一个命令的输出 可以通过管道 做为 另一个命令的输入 可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两端，左端塞东西（写），右端取东西（读） 常用的管道命令有： more：分屏显示内容 grep：在命令执行结果的基础上查询指定的文本 exec-exec 参数后面跟的是 command 命令，它的终止是以“；”为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。 例如： 1find . -name *.png -exec mv &#123;&#125; 移动目录/ \;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件和目录]]></title>
    <url>%2F2018%2F12%2F17%2FLinux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Linux 下的文件系统在 Linux 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）： Ubuntu 没有盘符这个概念，只有一个根目录 /，所有文件都在它下面 用户目录位于 /home/user，称之为用户工作目录或家目录，表示方式： 1~ Linux 主要目录速查表 /：根目录， 一般根目录下只存放目录 ，在 linux 下有且只有一个根目录，所有的东西都是从这里开始 当在终端里输入 /home，其实是在告诉电脑，先从 /（根目录）开始，再进入到 home 目录 /bin、/usr/bin：可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等 /boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub /dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt /etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab /etc/fstab /etc/init.d /etc/X11 /etc/sysconfig /etc/xinetd.d /home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下 ~ 表示当前用户的家目录 ~edu 表示用户 edu 的家目录 /lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助 /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下 /mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载 /opt：给主机额外安装软件所摆放的目录 /proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等 /root：系统管理员root的家目录 /sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能”查看”而不能设置和使用 /tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下 /srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内 /usr：应用程序存放目录 /usr/bin：存放应用程序 /usr/share：存放共享数据 /usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local：存放软件升级包 /usr/share/doc：系统说明文件存放目录 /usr/share/man：程序说明文件存放目录 /var：放置系统执行过程中经常变化的文件 /var/log：随时更改的日志文件 /var/spool/mail：邮件存放的目录 /var/run：程序或服务启动后，其 PID 存放在该目录下]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[find + mv 批量移动文件]]></title>
    <url>%2F2018%2F12%2F07%2Ffind-mv-%E6%89%B9%E9%87%8F%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[12# \ 表示结束 &#123;&#125; 表示find搜索的结果find . -name *.png -exec mv &#123;&#125; 移动目录/ \;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS NSNotification本地通知]]></title>
    <url>%2F2018%2F11%2F28%2FiOS-NSNotification%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5%2F</url>
    <content type="text"><![CDATA[iOS10 废弃了 UILocalNotification，采用了新的UserNotifications Framework来推送通知。 注册推送1234567891011121314151617181920212223242526272829303132#import &lt;UserNotifications/UserNotifications.h&gt;#import "AppDelegate.h"@interface AppDelegate ()@end@implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; if (@available(iOS 10.0, *)) &#123; // 使用 UNUserNotificationCenter 来管理通知 UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; //监听回调事件 //center.delegate = self; //iOS 10 使用以下方法注册，才能得到授权，注册通知以后，会自动注册 deviceToken，如果获取不到 deviceToken，Xcode8下要注意开启 Capability-&gt;Push Notification。 [center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert + UNAuthorizationOptionSound) completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; &#125;]; //获取当前的通知设置，UNNotificationSettings 是只读对象，不能直接修改，只能通过以下方法获取 [center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123; &#125;]; &#125; return YES;&#125;@end 使用本地通知123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105- (void)showLocalNotificationWithTitle:(NSString *)title notificationId:(NSString *)notificationId &#123; if (@available(iOS 10.0, *)) &#123; //新增前先清楚已注册的相同ID的本地推送 UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; [center removePendingNotificationRequestsWithIdentifiers:@[notificationId]]; //创建一个通知内容对象 UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init]; content.title = [NSString localizedUserNotificationStringForKey:title arguments:nil]; //content.body = [NSString localizedUserNotificationStringForKey:@"消息" arguments:nil]; // content.sound = [UNNotificationSound defaultSound]; content.userInfo = @&#123;kClickLocalNotification: notificationId&#125;; //设置n秒后推送 UNTimeIntervalNotificationTrigger *trigger = [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:1 repeats:NO]; UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:notificationId content:content trigger:trigger]; //添加 [center addNotificationRequest:request withCompletionHandler:nil]; &#125; else &#123; //新增前先清楚已注册的相同ID的本地推送 [self deleteLocadNotificationWithNotificationId:notificationId]; UILocalNotification *notification = [[UILocalNotification alloc] init]; //触发通知的时间 notification.fireDate = [NSDate dateWithTimeIntervalSinceNow:1]; //时区 notification.timeZone = [NSTimeZone defaultTimeZone]; //重复次数 kCFCalendarUnitEra为不重复 notification.repeatInterval = kCFCalendarUnitEra; //通知内容 notification.alertBody = title; notification.applicationIconBadgeNumber = 0; //通知声音 notification.soundName = UILocalNotificationDefaultSoundName; //通知dict notification.userInfo = @&#123;kClickLocalNotification: notificationId&#125;; // ios8后，需要添加这个注册，才能得到授权 if ([[UIApplication sharedApplication] respondsToSelector:@selector(registerUserNotificationSettings:)]) &#123; UIUserNotificationType type = UIUserNotificationTypeAlert | UIUserNotificationTypeBadge; //不使用UIUserNotificationTypeSound UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:type categories:nil]; [[UIApplication sharedApplication] registerUserNotificationSettings:settings]; &#125; else &#123; &#125; //执行通知注册 [[UIApplication sharedApplication] scheduleLocalNotification:notification]; &#125;&#125;- (void)deleteLocadNotificationWithNotificationId:(NSString *)notificationId &#123; if (@available(iOS 10.0, *)) &#123; /* removePendingNotificationRequestsWithIdentifiers 删除特定等待递送的通知 removeDeliveredNotificationsWithIdentifiers //删除特定已经递送的通知 */ [[UNUserNotificationCenter currentNotificationCenter] removeDeliveredNotificationsWithIdentifiers:@[notificationId]]; &#125; else &#123; UILocalNotification * notification = [self queryNotificationWithNotificatioId:notificationId]; if (notification) &#123; [[UIApplication sharedApplication] cancelLocalNotification:notification]; &#125; &#125;&#125;//查询符合条件的本地推送- (UILocalNotification *)queryNotificationWithNotificatioId:(NSString *)notificatioId &#123; NSArray * notifications = [self queryAllSystemNotifications]; __block UILocalNotification * localnotification = nil; if (notifications.count &gt; 0) &#123; [notifications enumerateObjectsUsingBlock:^(UILocalNotification * obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; //查找符合条件的本地推送 if ([obj.userInfo containsObjectForKey:kClickLocalNotification] &amp;&amp; [obj.userInfo[kClickLocalNotification] isEqualToString:notificatioId]) &#123; localnotification = obj; *stop = YES; &#125; &#125;]; &#125; return localnotification;&#125;//查询所有已注册的本地推送- (NSArray *)queryAllSystemNotifications &#123; return [[UIApplication sharedApplication] scheduledLocalNotifications];&#125; 12getPendingNotificationRequestsWithCompletionHandler: //获取所有等待递送的通知getDeliveredNotificationsWithCompletionHandler: //获取所有已经递送的通知]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git忽略.DS_Store文件]]></title>
    <url>%2F2018%2F10%2F18%2Fgit%E5%BF%BD%E7%95%A5-DS-Store%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. 先删除原有的.DS_Store1find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch1 命令解释：在当前文件夹以及当前文件夹的子文件夹中找到所有的.DS_Store文件，并将找到的文件通过管道传给xargs来处理。注意几个参数的理解：-print0：在find后不添加换行符（-print默认会添加换行符）-0：将管道送来的字符串当做普通的字符串，不做任何转义处理。 2. 建立.gitignore文件vi .gitignore。然后添加.DS_Store作为忽略：shell 1*/.DS_Store 3. 提交到git12git add .gitignoregit commit -m 'delete .DS_Store']]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
